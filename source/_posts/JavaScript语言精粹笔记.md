---
title: JavaScript语言精粹笔记
date: 2017-1-8 13:30:00
categories: Reading
tags: [JavaScript]
---


* 对象通过引用来传递，它们**永远不会被复制**。
    ```
    var x= stooge;
    x.nickName = 'Curly';
    var nick = stooge.nickName; //因为x和stooge是指向同一个对象的引用，所以nick为'Curly'
    var a = {}, b = {}, c = {};  //a, b 和 c 每个都引用一个不同的空对象
    a = b= c = {};  //a, b 和 c 都引用同一个空对象
    ```

* 每个对象都连接到一个**原型对象**，并且它可以从中继承属性。所有通过对象字面量创建的对象都连接到`Object.prototype`，它是`JavaScript`中的标配对象。

<!-- more -->

* 全局变量削弱了程序的灵活性，应该避免使用。最小化使用全局变量的方法之一是为你的应用只创建一个**唯一的全局变量**： `var MYAPP = {}` ，所有变量都存入该对象中。

* 当今大多数语言都是基于类的语言，而`JavaScript`是一门**基于原型继承**的语言，这意味着对象可以直接从其他对象继承属性。

* 一个**函数总是会返回一个值**，如果没有指定返回值，则返回undefined，如果函数调用时在前面加上了new前缀，则返回this，指向该新对象。

* 大多数类C语言的语言都拥有**块级作用域**，即在一个代码块中（括在一对花括号中的一组语句）定义的所有变量在代码块的外部是不可见的，但是`JavaScript`实际上并不支持块级作用域，只有函数作用域。很多语言推荐尽可能延迟声明变量，而对于`JavaScript`，由于它缺少块级作用域，所以最好的做法是在函数体的顶部声明函数中可能用到的所有变量。

* 在循环中创建函数只会带来无谓的计算，还会引起混淆，所以应该**避免在循环中创建函数**。

* `JavaScript`中的 `array` 和 `object` 类似，与传统的线性分配内存的数组不同。**允许数组包含任意混合类型的值**。

* `JavaScript`中的 `array` 的 `length` 属性的值是这个**数组的最大整数属性名加上1**，不一定等于数组里的属性的个数：
    ```
    var myArray = [];
    myArray.length        // 0  此时数组为空
    myArray[100] = 'abc';    // 属性名为100，即下标
    myArray.length        // 101  此时数组只包含一个属性
    ```
    
* `JavaScript`中数组和对象没有本质上的区别，而至于是**使用数组还是对象的规则**为：当属性名是小而连续的整数时，就应该使用数组，否则使用对象。

* `JavaScript`有两组相等运算符：`===` 和 `!==` ，以及 `==` 和 `!=` 。前者会按照你期望的方式工作，如果两个运算数类型一致且值相同，那么 `===` 返回 `true` ， `!=` 返回 `false` 。而后者只有在两个运算数类型一致时才会做出正确的判断，如果两个运算数是不同的类型，它们试图去强制转换值的类型。因此建议**永远不要使用 `==` 和 `!=` ，只用 `===` 和 `!==`**。

* `JavaScript`中应该**避免使用** `++` 、`--` 、位运算符、`new` 、`void` 。

* `JavaScript`中的 `for in` 语句可以用来遍历对象的所有属性的名字，但是它也会遍历出所有从原型链中继承而来的成员属性，所以**每个 `for in` 语句的主体应该被包围在一个用于过滤的 `if` 语句中**，用来排除函数或者从原型继承而来的属性。
    ```
    for (name in object) {
        if (object.hasOwnProperty(name)) {
            ...
        }
    }
    
    ```
